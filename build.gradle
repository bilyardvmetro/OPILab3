import org.xml.sax.helpers.DefaultHandler

import javax.xml.parsers.DocumentBuilderFactory
import java.security.MessageDigest

plugins {
    id 'java'
    id 'war'
}

group 'com.WebLab4'
version '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

ext {
    junitVersion = '5.11.0-M2'
    seleniumVersion = '4.31.0'
}
configurations {
    functionalTestImplementation.extendsFrom testImplementation
    functionalTestRuntimeOnly.extendsFrom testRuntimeOnly
}

sourceCompatibility = '17'
targetCompatibility = '17'

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

dependencies {
    // https://mvnrepository.com/artifact/jakarta.platform/jakarta.jakartaee-web-api
    compileOnly 'jakarta.platform:jakarta.jakartaee-web-api:10.0.0'
    // https://mvnrepository.com/artifact/org.projectlombok/lombok
    compileOnly 'org.projectlombok:lombok:1.18.38'
    annotationProcessor 'org.projectlombok:lombok:1.18.38'


    implementation('org.hibernate:hibernate-core:7.0.0.Alpha3')
    // https://www.ibm.com/docs/hr/was-nd/8.5.5?topic=services-jaxb
    implementation('org.glassfish.jaxb:jaxb-runtime:3.0.0')
    // https://mvnrepository.com/artifact/javax.xml.bind/jaxb-api
    implementation 'javax.xml.bind:jaxb-api:2.3.1'
    // https://mvnrepository.com/artifact/org.glassfish.jersey.containers/jersey-container-servlet
    implementation 'org.glassfish.jersey.containers:jersey-container-servlet:3.0.0'
    // https://mvnrepository.com/artifact/org.glassfish.jersey.media/jersey-media-json-binding
    implementation 'org.glassfish.jersey.media:jersey-media-json-binding:3.0.0'
    // https://mvnrepository.com/artifact/org.glassfish.jersey.inject/jersey-hk2
    implementation 'org.glassfish.jersey.inject:jersey-hk2:3.0.0'
    // https://mvnrepository.com/artifact/org.mindrot/jbcrypt
    implementation 'org.mindrot:jbcrypt:0.4'
    // https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt
    implementation 'io.jsonwebtoken:jjwt:0.9.1'

    // Основная реализация XML DOM/SAX парсера
    implementation 'xerces:xercesImpl:2.12.2'
    // Интерфейсы (javax.xml.parsers, org.w3c.dom и др.)
    implementation 'xml-apis:xml-apis:1.4.01'

    implementation("org.junit.jupiter:junit-jupiter-api:${junitVersion}")       // testImplementation
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:${junitVersion}")

    implementation "org.junit.platform:junit-platform-console:1.9.2"        // func testImplementation
    implementation "org.apiguardian:apiguardian-api:1.1.2"                  // func testImplementation
    implementation "org.seleniumhq.selenium:selenium-java:${seleniumVersion}" // func testImplementation
}

tasks.register('music') {
    description = 'Plays music after build'
    group = 'OPILab3 targets'

    doLast {
        def songFile = file('music/i_got_a_brand_new_saxophone.mp3')
        def songURI = songFile.toURI().toString()

        def powershellCommand = """
            Add-Type -AssemblyName presentationCore;
            \$player = New-Object System.Windows.Media.MediaPlayer;
            \$player.Open([uri] '${songURI}');
            \$player.Play();
            Start-Sleep -Seconds 10
        """

        if (System.properties['os.name'].toString().toLowerCase().contains('windows')) {
            exec {
                commandLine 'powershell', '-Command', powershellCommand
            }
        } else {
            println "Unsupported OS for playing music :("
        }
    }
}

def srcDir = file('src/main/java/com/weblab4/opilab3')
ext.compileSucceeded = true

tasks.register('myCompile') {
    description = 'Compile .java files'
    group = 'OPILab3 targets'

    dependsOn native2ascii

    def outDir = file('build/classes/java/main')

    inputs.dir(srcDir)
    outputs.dir(outDir)

    doLast {
        try {
            outDir.mkdirs()
            def javaFiles = fileTree(srcDir).matching { include '**/*.java' }.files.collect { it.path }

            if (javaFiles.isEmpty()) {
                throw new GradleException("There are no .java files to compile")
            }

            def classpath = configurations.compileClasspath.files.join(File.pathSeparator)
            def command = ['javac', '-d', outDir.path]

            if (classpath) {
                command += ['-cp', classpath]
            }

            command += javaFiles

            println "Running: ${command.join(' ')}"
            def result = exec {
                commandLine command
                ignoreExitValue = true
            }

            copy {
                from 'src/main/resources'
                into 'build/resources/main'
            }

            if (result.exitValue == 0) {
                println "Compilation succeeded"
                compileSucceeded = true
            } else {
                println "Compilation failed"
                compileSucceeded = false
            }
        } catch (Exception e) {
            println "Ошибка при сборке: ${e.message}"
            buildSucceeded = false
        }

    }
    finalizedBy history
}

tasks.register('myBuild') {
    description = 'Build .jar file'
    group = 'OPILab3 targets'

    dependsOn myCompile

    doLast {
        def jarFile = file('build/libs/OPILab3.jar')
        def classesFiles = file('build/classes')
        def manifest = file('build/tmp/jar/MANIFEST.MF')

        jarFile.parentFile.mkdirs()

        if (!manifest.exists()) {
            manifest.parentFile.mkdirs()
            manifest.text = "Manifest-Version: 1.0\n"
        }

        def command = [
                'jar', 'cmf', manifest.absolutePath, jarFile.absolutePath,
                '-C', classesFiles.absolutePath, '.'
        ]

        println "Executing ${command.join(' ')}"
        exec {
            commandLine command
        }
        println "JAR-file ${jarFile} has been successfully built"
    }
    finalizedBy music
}

tasks.register('myClean') {
    description = 'Remove \'build\' directory'
    group = 'OPILab3 targets'

    doLast {
        def buildDir = file('build')

        if (buildDir.exists()) {
            println "Removing ${buildDir} directory..."
            buildDir.deleteDir()
        } else {
            println '\'build\' directory not found'
        }
    }
}

tasks.register('scp') {
    description = 'Send .jar file to specific server by scp'
    group = 'OPILab3 targets'
    dependsOn myBuild

    // Подразумевается, что на сервере и клиенте есть ssh ключи для отправки через scp без ввода пароля
    doLast {
        def server = 's413041@se.ifmo.ru:/home/studs/s413041/OPILab3'
        def command = ['scp', '-P', '2222', 'build/libs/OPILab3.jar', server]

        println "Executing ${command.join(' ')}"
        println "Sending .jar to ${server}..."
        exec {
            commandLine command
        }
    }
}

tasks.register('xml') {
    description = 'Validates all project\'s .xml files'
    group = 'OPILab3 targets'

    doLast {
        def xmlFiles = fileTree('src/main/resources') {
            include '**/*.xml'
        }

        def factory = DocumentBuilderFactory.newInstance()
        factory.setValidating(false)

        def builder = factory.newDocumentBuilder()
        builder.setErrorHandler(new DefaultHandler())

        xmlFiles.each {
            try {
                builder.parse(it)
                println "File ${it} is valid"
            } catch (Exception e) {
                println "Error in file ${it}: ${e.message}"
            }
        }
    }
}

static def calculateChecksum(File file, String algorithm) {
    def digest = MessageDigest.getInstance(algorithm)
    file.eachByte(4096) { buffer, bytesRead ->
        digest.update(buffer, 0, bytesRead)
    }
    return digest.digest().encodeHex()
}

tasks.register('generateJavadoc', Javadoc) {
    source = sourceSets.main.allJava
    classpath = sourceSets.main.compileClasspath
    destinationDir = file("build/docs/javadoc")
    title = "Project Documentation"
    options.memberLevel = JavadocMemberLevel.PUBLIC
    options.encoding = 'UTF-8'
}

tasks.register('javadocJar', Jar) {
    archiveClassifier.set('javadoc')
    from(tasks.named('generateJavadoc').map { task -> ((Javadoc) task).destinationDir })
}

tasks.register('doc') {
    description = 'Generates javadoc and add MD5 and SHA-1 classes hashes to MANIFEST.MF'
    group = 'OPILab3 targets'

    dependsOn generateJavadoc, javadocJar

    doLast {
        def manifestFile = file("build/tmp/jar/MANIFEST.MF")

        if (manifestFile.exists()) {
            def manifestContent = new StringBuilder()
            manifestContent << "Manifest-Version: 1.0\n"

            def files = sourceSets.main.allJava.filter { it.exists() }

            files.each { file ->
                if (file.exists()) {
                    def md5 = calculateChecksum(file, 'MD5')
                    def sha1 = calculateChecksum(file, 'SHA-1')

                    manifestContent << "\nName: ${file.name}\n"
                    manifestContent << "MD5-Hash: ${md5}\n"
                    manifestContent << "SHA1-Hash: ${sha1}\n"
                }
            }
            manifestContent << "\n"

            manifestFile.parentFile.mkdirs()
            manifestFile.text = manifestContent.toString()
        } else {
            println "MANIFEST.MF not found"
        }

    }
}

tasks.register('packageJars', Zip) {
    from "build/team-builds"
    include "*.jar"
    archiveFileName = "builds.zip"
    destinationDirectory = buildDir
}

tasks.register('team') {
    description = 'Build previous 3 versions of project into .jar and .zip'
    group = 'OPILab3 targets'

    doLast {
        // получить имя текущей ветки
        def currentBranch = 'git rev-parse --abbrev-ref HEAD'.execute().text.trim()
        // получить хэши 3 коммитов предыдущих
        def revisions = 'git log -3 --pretty=format:"%H"'.execute().text.readLines()

        def outputDir = file("build/team-builds")
        outputDir.deleteDir()
        outputDir.mkdirs()

        revisions.each { commitId ->
            try {
                def shortId = commitId.substring(0, 7)
                println "Building revision: $shortId"

                // Переключаемся на коммит
                "git checkout $commitId --force".execute().waitFor()

                def result = exec {
                    workingDir project.rootDir
                    commandLine 'cmd', '/c', 'gradlew.bat', 'myBuild', '--stacktrace'
                    ignoreExitValue true
                }.exitValue

                if (result == 0) {
                    // Копируем JAR-файлы
                    fileTree(dir: "build/libs").matching {
                        include '*.jar'
                    }.each { jarFile ->
                        copy {
                            from jarFile
                            into outputDir
                            rename { "${jarFile.name - '.jar'}-${shortId}.jar" }
                        }
                    }
                } else {
                    println "Build failed for commit $shortId"
                }

            } catch (Exception e) {
                println "Error processing $commitId: ${e.message}"
            } finally {
                // Возвращаемся на исходную ветку
                "git checkout $currentBranch --force".execute().waitFor()
            }
        }
    }
    finalizedBy 'packageJars'
}

static String convertToUnicode(String input) {
    StringBuilder result = new StringBuilder()
    for (char c : input.toCharArray()) {
        if (c < 128) {
            result.append(c)
        } else {
            result.append(String.format('\\u%04X', (int) c))
        }
    }
    return result.toString()
}

tasks.register('native2ascii', Copy) {
    description = 'Converts localization files to ASCII-escaped Unicode'
    group = 'OPILab3 targets'

    def localizationDir = file('src/main/resources/locale')
    def tempDir = file("build/tmp/native2ascii")

    doFirst {
        tempDir.mkdirs()
    }

    from(localizationDir) {
        include '**/*.properties'
    }
    into tempDir

    doLast {
        fileTree(tempDir).include('**/*.properties').each { File file ->
            // Читаем содержимое файла в UTF-8
            String content = file.getText('UTF-8')

            // Конвертируем содержимое
            String convertedContent = convertToUnicode(content)

            // Перезаписываем файл
            file.write(convertedContent, 'ISO-8859-1')

            logger.lifecycle("Converted: ${file.name} (${content.length()} chars -> ${convertedContent.length()} chars)")
        }
    }
}

tasks.register('alt', Copy) {
    dependsOn myClean
    description = 'Create alternative version of project with another names of classes and variables'
    group = 'OPILab3 targets'

    def replacements = new Properties()
    file("properties/alt/replace.properties").withInputStream { replacements.load(it) }

    from sourceSets.main.java.srcDirs
    into "build/alt-src"

    eachFile { file ->
        if (file.name.endsWith('.java')) {
            filter { line ->
                def result = line
                replacements.each { original, replacement ->
                    result = result.replaceAll(original, replacement)
                }
                return result
            }
        }
    }

    rename { fileName ->
        def newName = fileName
        replacements.each { orig, alt ->
            newName = newName.replace(orig, alt)
        }
        newName
    }

    doFirst {
        mkdir "build/alt-src"
    }

    doLast {
        srcDir = file('build/alt-src')
    }
    finalizedBy myBuild
}

tasks.register('bringBackSrc') {
    srcDir = file('src/main/java/com/weblab4/opilab3')
    mustRunAfter myBuild
}

tasks.register('env') {
    group = 'opilab3 targets'
    description = 'Build and Run project with environment from "environment.properties" file'

    doLast {
        // Чтение параметров из файла
        def props = new Properties()
        file("properties/env/environment.properties").withInputStream { props.load(it) }

        javaexec {
            executable = "${System.getProperty('java.home')}/bin/java"
            jvmArgs = props.getProperty("jvmArgs", "").split(' ').findAll { it }
            mainClass = props.getProperty("mainClass")
            classpath = sourceSets.main.runtimeClasspath
        }

    }
}

// Метод для получения списка измененных файлов
def getChangedFiles() {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'diff', '--name-only', 'HEAD'
        standardOutput = stdout
        ignoreExitValue = true
    }
    return stdout.toString().trim().split('\n').toList()
}

// Метод для проверки изменений в исключенных классах
static def hasExcludedChanges(changedFiles, excludedClassesFile) {
    def excludedClasses = excludedClassesFile.readLines().findAll { it.trim() && !it.startsWith('#') }
    return changedFiles.any { changedFile ->
        excludedClasses.any { excluded ->
            changedFile.contains(excluded)
        }
    }
}

tasks.register('diff') {
    group = 'opilab3 targets'
    description = 'Checks working copy state and commits if changes don\\\'t affect classes from excludedClasses.txt file'

    def excludedClassesFile = file('properties/excludedClasses.txt')

    doLast {
        if (!excludedClassesFile.exists()) {
            throw new GradleException("Excluded classes file not found: ${excludedClassesFile}")
        }

        def changedFiles = getChangedFiles()
        if (hasExcludedChanges(changedFiles, excludedClassesFile)) {
            logger.lifecycle('Commit skipped: changes detected in excluded classes')
        } else {
            def result = exec {
                commandLine 'git', 'commit', '-a', '-m', 'Auto-commit: changes not affecting excluded classes'
                logger.lifecycle('Changes committed successfully')
                ignoreExitValue = true
            }
            if (result) {
                println 'no changes'
            }
        }
    }

}

tasks.register('history') {
    group = 'opilab3 targets'
    description = 'Finds the last working revision by sequentially checking previous versions until compilation succeeds'

    doLast {
        if (compileSucceeded) {
            println 'Compilation Succeeded. Task "history" skipped'
            return
        }

        println 'Compilation failed. Starting task "history"...'

        def maxAttempts = 50
        def attempt = 0

        def firstCommit = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'rev-list', '--max-parents=0', 'HEAD'
            standardOutput = firstCommit
        }
        firstCommit = firstCommit.toString().trim()

        while (!compileSucceeded && attempt < maxAttempts) {
            attempt++
            println "Attempt #$attempt: Switching to previous commit..."

            // Получаем текущий коммит
            def currentCommit = new ByteArrayOutputStream()
            exec {
                commandLine 'git', 'rev-parse', 'HEAD'
                standardOutput = currentCommit
            }
            currentCommit = currentCommit.toString().trim()

            if (currentCommit == firstCommit) {
                println "First commit reached. Making diff.txt file..."

                def allCommits = new ByteArrayOutputStream()
                exec {
                    commandLine 'git', 'rev-list', '--reverse', '--all'
                    standardOutput = allCommits
                    ignoreExitValue true
                }
                def commitList = allCommits.toString().trim().split("\n")

                if (commitList.size() > 1) {
                    def secondCommit = commitList[1] // второй коммит после самого первого

                    def diffOutput = new ByteArrayOutputStream()
                    exec {
                        commandLine 'git', 'diff', currentCommit, secondCommit
                        standardOutput = diffOutput
                        ignoreExitValue true
                    }

                    def diffFile = file("build/diff.txt")
                    diffFile.parentFile.mkdirs()
                    exec {
                        commandLine 'git', 'diff', currentCommit, secondCommit
                        standardOutput = new FileOutputStream(diffFile)
                        ignoreExitValue true
                    }
                    println "Diff now in: ${diffFile.absolutePath}"
                    compileSucceeded = true

                } else {
                    println "There is no next commit"
                }

                break
            }

            // Откат на предыдущий коммит
            exec {
                commandLine 'git', 'checkout', 'HEAD^'
            }

            // Снова пробуем собрать
            println "Trying to compile..."

            def src = file('src/main/java/com/weblab4/opilab3')
            def outDir = file('build/classes/java/main')
            outDir.mkdirs()
            def javaFiles = fileTree(src).matching { include '**/*.java' }.files.collect { it.path }

            if (javaFiles.isEmpty()) {
                throw new GradleException("There are no .java files to compile")
            }

            def classpath = configurations.compileClasspath.files.join(File.pathSeparator)
            def command = ['javac', '-d', outDir.path]

            if (classpath) {
                command += ['-cp', classpath]
            }

            command += javaFiles

            def result = exec {
                commandLine command
                ignoreExitValue = true
            }

            if (result.exitValue == 0) {
                println "Compile Success! Making diff.txt ..."

                def successCommit = new ByteArrayOutputStream()
                exec {
                    commandLine 'git', 'rev-parse', 'HEAD'
                    standardOutput = successCommit
                }
                successCommit = successCommit.toString().trim()

                def allCommitsFromSuccess = new ByteArrayOutputStream()
                exec {
                    commandLine 'git', 'rev-list', '--reverse', 'HEAD..master'
                    standardOutput = allCommitsFromSuccess
                    ignoreExitValue true
                }
                def commitList = allCommitsFromSuccess.toString().trim().split("\n")

                def secondCommit = commitList[0] // cледующий коммит после текущего

                def diffFile = file("build/diff.txt")
                diffFile.parentFile.mkdirs()
                exec {
                    commandLine 'git', 'diff', successCommit, secondCommit
                    standardOutput = new FileOutputStream(diffFile)
                    ignoreExitValue true
                }
                println "Diff now in: ${diffFile.absolutePath}"
                compileSucceeded = true

                break

            } else {
                println "Compilation still failed."
            }
        }

        if (!compileSucceeded) {
            throw new GradleException("Unable to build project on any revision")
        }
        exec {
            commandLine 'git', 'checkout', 'main'
        }
    }
}

tasks.register('report') {
    group = 'opilab3 targets'


    doLast {
        if (file("build/test-success.flag").exists()) {
            println "Commiting test report to git repo..."

            exec {
                workingDir '.'
                commandLine 'git', 'add', 'test-results'
            }

            exec {
                workingDir '.'
                commandLine 'git', 'commit', '-m', 'Auto commit: Add test report'
            }

            println "Test reports added to git repo!"
            file("build/test-success.flag").delete()
        } else {
            println 'Task "report" skip due to failed tests'
        }
    }
}

tasks.register('deployFront') {
    group = 'opilab3 func testing'

    doLast {
        def processBuilder = new ProcessBuilder()
                .directory(file('E:/WebLab4Frontend'))
                .command('cmd', '/c', 'start', 'ng', 'serve')
                .inheritIO()
        processBuilder.start()
    }

}

tasks.register('stopFront') {
    group = 'opilab3 func testing'

    doLast {
        println 'Searching for process on port 4200...'

        def findProcessOutput = new ByteArrayOutputStream()
        exec {
            commandLine 'cmd', '/c', 'netstat -aon | findstr :4200'
            standardOutput = findProcessOutput
            ignoreExitValue true // чтобы не упасть, если ничего не найдено
        }

        def output = findProcessOutput.toString('CP866').trim()

        if (output.isEmpty()) {
            println 'No process running on 4200.'
        } else {
            println "Found process:\n${output}"

            // Извлечем PID процесса
            def lines = output.readLines()
            def pidList = lines.collect { it.split(/\s+/)[-1] }.unique()
            pidList = pidList.findAll {it != '0'}

            pidList.each { pid ->
                println "Stopping process PID = $pid..."
                exec {
                    commandLine 'cmd', '/c', "taskkill /PID $pid /F"
                    ignoreExitValue true
                }
            }
            println 'ng serve stopped'
        }
    }
}

def wildFlyDir = file('E:/wildfly-33.0.2.Final')

tasks.register('startWildfly') {
    group = 'opilab3 func testing'

    dependsOn deployFront

    doLast {
        def processBuilder = new ProcessBuilder()
                .directory(wildFlyDir)
                .command('cmd', '/c', 'start', wildFlyDir.absolutePath + '/bin/standalone.bat')
                .inheritIO()
        processBuilder.start()

        println 'Starting WildFly...'

        // Ждем пока порт 8080 откроется
        int timeoutSeconds = 60
        int waited = 0
        boolean isStarted = false

        while (waited < timeoutSeconds) {
            try {
                Socket socket = new Socket('localhost', 8080)
                socket.close()
                isStarted = true
                break
            } catch (Exception ignored) {
                sleep(1000) // ждем 1 секунду
                waited++
            }
        }

        if (isStarted) {
            println "WildFly started successfully!"
        } else {
            throw new GradleException("Couldn't start WildFly in ${timeoutSeconds} seconds.")
        }
    }
}

myCompile.finalizedBy war

tasks.register('deployWarOnWildfly') {
    group = 'opilab3 func testing'

    dependsOn startWildfly, war, myBuild
    mustRunAfter myBuild

    doLast {
        println 'Деплой WAR на сервер WildFly...'

        exec {
            workingDir "E:/OPILab3/build"
            commandLine wildFlyDir.absolutePath + '/bin/jboss-cli.bat',
                    '--connect', '--command=undeploy OPILab3-1.0-SNAPSHOT.war'
            ignoreExitValue = true
        }

        exec {
            workingDir "E:/OPILab3/build"
            commandLine wildFlyDir.absolutePath + '/bin/jboss-cli.bat',
                    '--connect', '--command=deploy E:/OPILab3/build/libs/OPILab3-1.0-SNAPSHOT.war --force'
        }
    }
}

tasks.register('stopWildfly') {
    group = 'opilab3 func testing'

    doLast {
        println 'Stopping WildFly...'

        exec {
            workingDir "${wildFlyDir}"
            commandLine 'cmd', '/c', wildFlyDir.absolutePath + '/bin/jboss-cli.bat --connect --command=:shutdown'
            ignoreExitValue = true // если сервер уже остановлен, не падать
        }

        println "WildFly Stopped!"
    }
}

def functionalSrcDir = 'src/main/java/funcTests'
def functionalClassesDir = "build/classes/java/main/funcTests"

tasks.register('compileFuncTests') {
    group = 'opilab3 func testing'

    dependsOn deployWarOnWildfly

    inputs.dir functionalSrcDir
    outputs.dir functionalClassesDir

    doLast {
        println "Compiling functional test classes..."

        file(functionalClassesDir).mkdirs()

        def srcFiles = fileTree(dir: functionalSrcDir, include: '**/*.java').files*.path
        if (srcFiles.isEmpty()) {
            println "No functional test sources found."
            return
        }

        def classpath = configurations.functionalTestImplementation.asPath
        def cmd = ["javac", "-d", functionalClassesDir, "-cp", classpath] + srcFiles

        exec {
            commandLine cmd
        }

        println "Functional tests compiled successfully."
    }
}

tasks.register("runFuncTests") {
    group = 'opilab3 func testing'
    dependsOn compileFuncTests

    doLast {
        println "Running functional tests..."

        def classpath = files(
                functionalClassesDir,
                configurations.functionalTestRuntimeOnly,
                configurations.functionalTestImplementation
        ).asPath

        def reportDir = "test-results/func-tests"
        mkdir(reportDir)

        def cmd = [
                "java",
                "-cp", classpath,
                "org.junit.platform.console.ConsoleLauncher",
                "--scan-class-path", functionalClassesDir,
                "--details", "tree",
                "--details-theme", "ascii",
                "--reports-dir=${reportDir}"
        ]

        def res = exec {
            commandLine cmd
            ignoreExitValue = true
        }

        if (res.exitValue == 0) {
            println "All tests passed!"
            file("build/test-success.flag").text = "success"
        }  else {
            println "Tests failed."
        }

        println "Functional tests run finished."
    }
}
runFuncTests.finalizedBy stopWildfly, stopFront, report

test {
    useJUnitPlatform()
}